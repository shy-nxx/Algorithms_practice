package swea_test;

public class Sift_op {
/**
 * 비트 연산자

0과 1로 표현이 가능한 정수타입만 비트 연산이 가능하다.

피연산자를 int 형으로 자동 형변환

비트 반전 연산자(~), 틸드 연산자

정수 타입의 피연산자에만 사용
피연연사즐 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전
부호가 반대인 새로운 값이 산출됨
비트 논리 연산자(&, |, ^)

비트논리 AND 연산자(&): 두 비트 모두 1일 경우에만 연산 결과가 1
비트논리 OR 연산자(|): 두 비트 중 하나라도 1이면 연산 결과 1
비트논리 XOR 연산자(^): 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1
비트 이동 연산자(<<, >>, >>>), 쉬프트 연산자

a << b: 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0으로 채워짐)
a >> b: 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 정수 a의 최상위 부호 비트와 같은 값으로 채워짐)
a>>>b: 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0으로 채워짐)

 */
	public static void main(String [] args){
		byte a = 10;  // 00001010
		byte b = 9;   // 00001001
		byte c = 2;  //시프트할 칸수
		System.out.println(a + " & " + b + " = " + (a&b));  //논리합
		System.out.println(a + " | " + b + " = " + (a|b));  //논리곱
		System.out.println(a + " ^ " + b + " = " + (a^b));  //배타적 논리합(xor)
		System.out.println("~10 = " + (~a));  //a 의 보수(반전)
		System.out.println(a + " << " + c + " = " + (a<<c));  //왼쪽 1비트 시프트(뒤를 0 으로 채움)
		System.out.println(a + " >> " + c + " = " + (a>>c));  //오른쪽 1비트 시프트(앞을 밀리기전 첫째자리와 동일한 비트로 채움)
		System.out.println(a + " >>> " + c + " = " + (a>>>c)); //오른쪽 1비트 논리 시프트(앞을 0 으로 채움)
		System.out.println(-1 * a + " >> " + c + " = " + (-1*a >> c));
	}
}


